<br /><center class="subtitle">Fudan ICPC Summer Training Camp 2019</center>

# Petrozavodsk Winter-2019 Japanese Contest 训练报告

<br />
<center>[Fudan U2] 刘明君、孙亮亮、薛振梁</center>
<center>2019 年 8 月 7 日</center>
<br />

### 概况

比赛中通过 7 题，赛后补 2 题，总共通过 9 题。

### 比赛过程

<pre class="replay">
|0........|30.......|60.......|90.......|120......|150......|180......|210......|240......|270...... (min)
                      x C                x     J    G                h          i                  e [lmj]
             +     +      K                         G                h          i                  e [sll]
   x  + +b     A               B               g       x   x  D      h          i                  e [xzl]
*^^^^^^^^^*^^^^^^^^^*^^^^^^^^^*^^^^^^^^^*^^^^^^^^^*^^^^^^^^^*^^^^^^^^^*^^^^^^^^^*^^^^^^^^^*^^^^^^^^^
 x   Wrong Answer / Presentation Error              !   Runtime Error
 +   Time Limit Exceeded                            =   Memory Limit Exceeded
A-N  Accepted                                      a-n  可做但未通过 / 弃题
</pre>

### 总结

**刘明君：**开场看错 D 题，还写了个假的代码，清醒了一下感觉自己搞不出这道题，就丢给 xzl 了。然后开了 C 题和 J 题，很快过掉了。一半时间以后，队伍在三开 E、H、I，都是有些想法，有不足以通过的，讨论一段时间后发现 E 比较可做，但是也没有讨论清楚。乱搞和构造水平不太够。

**孙亮亮：**整体发挥不错，但 E 题思路不够清晰浪费了很多时间。

**薛振梁：**这一次进展比较顺利，前期题目基本上没有卡题。主要问题是实力不够，中后期就做不出题了。最后队伍三个人搞 E 题结果没有写出来，说明团队交流还需要磨合一下。

***

### 解题报告

#### A. Digits Are Not Just Characters

**情况**　通过

**题意**　给一堆文件名，要求将文件名中连续的数字看作一个整体，然后比两个文件名的字典序大小。

**题解**　简单解析一下后放到 `vector` 中就可以随意比大小了。

<hr />
#### B. Arithmetic Progressions

**情况**　通过

**题意**　给定一个大小为 $n$ 的集合，问其中能够组成最长的等差数列的长度是多少。$n \leqslant 5000$。

**题解**　首先将所有数字按升序排序。然后从小到大枚举等差数列的前两位，暴力用哈希表检查其最长能扩展的地方，注意其中被扩展的数字可以打一个标记，这样之后就不用再次重复枚举了。时间复杂度为 $Θ(n^2)$。

<hr />
#### C. Emergency Evacuation

**情况**　通过

**题意**　有一个 $n×2m$ 的大巴车，中间是过道，有一些位置有人，现在人们想走到 $(n,m)$ 的过道最后端下车，但是过道很窄，每次只能走一个人。每个时间段一个人走一个位子，求所有人下车的最早时间。

**题解**　考虑所有人单独存在时的下车时间，按这个时间排好序，如果两个人在同时下车，那么一定会发生的事情是一个人等一个时间，然后跟在上一个人下车。所以每个人判断一下理想下车时间和前一个人的实际下车时间取个较大值就是他的实际下车时间。

<hr />
#### D. Shortest Common Non-Subsequence

**情况**　通过

**题意**　给两个长度分别为 $n$ 和 $m$ 的 `01` 序列，要求一个最短的、字典序最小的 `01` 序列，满足其不是任意一个给定的序列的子序列。$n,\ m \leqslant 1000$。

**题解**　考虑子序列的匹配方式，是采取的贪心的做法。现在我们尝试用 DP 来对抗这个贪心算法。设 $f[i][j]$ 表示贪心算法在第一个串匹配到 $i$，在第二个串匹配到 $j$ 的最少字符数。每次枚举下一个字符是谁，然后 $i$ 和 $j$ 分别会移动到对应串中下一个最近的是枚举字符的位置。DP 完成后即得到了最短长度。然后从后往前 BFS 标记出所有合法的状态，从而可以算出字典序最小的方案。时间复杂度 $Θ(nm)$。

<hr />
#### E. Eulerian Flight Tour

**情况**　补题通过

**题意**　给一张图，问能不能从补图中选出若干条边加入到原图，使得原图有欧拉回路。

**题解**　首先欧拉回路等价于所有点度数是偶数，并且图联通。如果不考虑图联通的情况就是有一些点要加奇数条边，那么在补图上面找个生成树深搜，退栈的时候看一下需不需要边，需要就把和父亲的边连起来。如果根还需要一条边，就是无解。然后考虑在加了边的图上看是不是联通，如果联通就完成了，如果不连通，但是每个联通块至少有两个点，那么对两两联通块的各两个点，把这四条边连上，就还全是偶数度，并且联通了。那么如果有一个点的块的话，在最开始，判断有没有孤立点，有的话，如果点数是奇数，直接连成一个团，如果是偶数，并且有孤立点，那么如果剩下的是个团，就无解，否则把剩下的连成团，但是少加一条边，而是把这两个点和孤立点连起来就可以了。

<hr />
#### G. What Goes Up Must Come Down

**情况**　通过

**题意**　给出一个序列，通过交换相邻两个数的操作使得序列变成先升后降的序列。

**题解**　考虑到如果先移动最小的将不会影响序列的升降规律，于是从最小数开始考虑放在最大值的左边还是右边，如果左边必它大的数更少则放左边否则放右边，对于若干个数相等的情况，则考虑最左边的那个放左边和最右边的那个放右边哪个代价更大。

<hr />
#### H. Four-Coloring

**情况**　补题通过

**题意**　给一张平面图，保证每条平行坐标轴或者是 $45$ 度的，求一个点的四染色。

**题解**　考虑对坐标排序，比如 $x$ 是第一关键字从小到大，$y$ 是第二关键字从小到大，那么处理一个点时，最多有 $4$ 个点已经被染了颜色，那么如果是四个不同的颜色的话，取 $x$ 轴向下，$y$ 轴向右，那么考虑把左边的点的颜色换成上边点的颜色，并且把相连的这两个颜色全部交换，从左边点的颜色开始搜索，看有没有一条到上边点的只有这两种颜色交替出现的路径，有的话那么就把左上的点包起来了，就考虑把左上的点及联通的点换成右上的点的颜色，否则没有这样的路径的话就把左边点的颜色换成上边的颜色。

<hr />
#### J. Colorful Tree

**情况**　通过

**题意**　给一棵树，点有颜色，每次改一个点的颜色，或者问一个颜色的点构成的最小联通子图的边的数量。

**题解**　对每个颜色处理，维护一个 `set`，按照 DFS 序排列，类似于建立起虚树，维护虚树的大小，再减掉虚树的根和整棵树的根的距离就是这个颜色的答案。在增加或者删除一个点就是找与其 DFS 序相邻的点的 LCA，这个点到 LCA 的就是改变的答案的大小。

<hr />
#### K. Sixth Sense

**情况**　通过

**题意**　两个人打牌，B 会按特定顺序出牌，已知 A 手中的牌，要求确定 A 的出牌顺序来使得 A 赢的次数（严格大算赢）最多，且出牌顺序字典序最大。

**题解**　给定两个序列判断最多赢得的次数在排序后可以贪心做到 $\mathrm O(n)$，于是可以先求出最多赢的次数，然后考虑每一次出哪张牌，可以发现如果确定了赢或不赢，则放可以赢或不赢的最小的牌最优，但我们要求字典序最大，因此可以确定赢或不赢后二分可以放的最大的牌，如果判断是否可以放呢？只需放入之后再 check 之后能赢的最大场次即可。那么如果判断该不该赢呢？可以找到比当前 B 要出的牌大的最小数放在此处看，同样 check 之后能赢的最大场次看是否变坏即可。