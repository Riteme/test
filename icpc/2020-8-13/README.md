02 Breaking Down News

题意：给定一个长度为 $n$ 的序列 $a_i$，$a_i \in \{-1,0,1\}$，要求把这个序列分为若干段，使得和为正数的段的数量减去和为负数的段的数量之差最大。

题解：首先可以对 $a_i$ 做个前缀和，这样就变成选若干个点，前缀和作为点的高度，然后就变成最大化上升段的数量减去下降段的数量。由于每次前缀和变化最多为 $1$，所以可以对每个前缀和的值维护一个 DP 值的单调队列，然后分较大的值和较小的值维护两个堆即可。



09 Isomorphic Strings

题意：给定字符串 $s$，问是否存在一个长度大于 $1$ 的串 $t$，满足 $s$ 是由 $t$ 的若干个循环同构的串拼接而来的。

题解：首先可以枚举 $t$ 的长度，然后就只用判断每段是否都与第一段循环同构了。可以用 KMP 算出每段与第一段的最长公共前后缀，然后剩下的部分用 hash 判断是否相等。



12 Linuber File System

题意：给定一棵树，每个点有个最终的值域区间 $[l_i,r_i]$，每个点的初始值是 $0$。现在可以使用子树加操作，需要使用最少的子树加操作使得每个点的权值满足值域区间的要求。

题解：首先，如果固定每个点的最终权值，那么很容易构造出最少操作次数的操作。因此，问题就相当于给每个节点赋一个值域区间范围内的权值，然后要最大化两个端点的权值相同的边的数量。原来的树根可以看作是和一个权值固定为 $0$ 的点相连的。

这里考虑直接 DP，设 $f(i, x)$ 表示子树 $i$ 的 DP 值，并且此时节点 $i$ 的权值为 $x$ 时的答案。这里 $x$ 的范围实在太大，但是我们需要注意到 $f(i,x)$ 是个关于 $x$ 的分段函数，这样一来就可以把第二维降到和 $n$ 同阶的级别了。之后维护分段函数的过程比较套路了。