<br /><center class="subtitle">Fudan ICPC Summer Training Camp 2019</center>

# 牛客网第五场训练报告

<br />
<center>[Fudan U2] 刘明君、孙亮亮、薛振梁</center>
<center>2019 年 8 月 1 日</center>
<br />

### 概况

比赛中通过 5 题，赛后补 5 题，总共通过 10 题。

### 比赛过程

<pre class="replay">
|0........|30.......|60.......|90.......|120......|150......|180......|210......|240......|270...... (min)
                               =G           xx x                F                                  j [lmj]
        !!     H                                                                          xxx    xxi [sll]
  A                   B                                                +       +   ++     x   x  x c [xzl]
*^^^^^^^^^*^^^^^^^^^*^^^^^^^^^*^^^^^^^^^*^^^^^^^^^*^^^^^^^^^*^^^^^^^^^*^^^^^^^^^*^^^^^^^^^*^^^^^^^^^
 x   Wrong Answer / Presentation Error              !   Runtime Error
 +   Time Limit Exceeded                            =   Memory Limit Exceeded
A-N  Accepted                                      a-n  可做但未通过 / 弃题
</pre>

开局 xzl 和 lmj 看了 A 题，sll 从后往前读题读到 H 觉得很可做，上去写了一发 H 段错误了，改了一会才 A 掉，但还是拿到 FB 了，之后 xzl 去过了 B，lmj 想到 G 题做法，之后发现误读了题意，后来修改了一下就 AC 了，之后 lmj 上机写 F，sll 和 xzl 讨论 C、I、J，之后 xzl 和 lmj 交替上机写 F 和 C，F 题通过之后 sll 和 lmj 说 J 题做法被发现读错题了，之后又找到了新的算法，一致认为很麻烦所以准备最后再写。C 题卡住之后 sll 上机写 I，C、I 都陷入卡题状态一直到比赛结束。Game over。

### 总结

**刘明君：**开场看到了 G，发现比较可做。1h 之后写的时候发现读错题了，赶紧改了一下。想完 G 看到了 F，转化了一下问题就可以做了，但是之前没写过输出方案，随便脑补的有些问题，浪费了一些时间。最后一起把 J 想出来了，但是因为 3h 之后 C 和 I 都在卡题，没有时间写了。

**孙亮亮：**本场比赛在约两个半小时的时候就已经想到 $8$ 道题的做法，但是代码的查错耗费太多时间，所以要多刷题要多刷题要多刷题。

**薛振梁：**这一次比赛初期势头良好，比赛题目难度不高，我们队伍至少想出了 $8$ 题。可惜队伍代码能力不强。F 题实际上 WoodCube 上有模板但不知道，写了 90min。之后 I 和 C 两道题因为细节问题一直 WA 到比赛结束，导致本来可做的 J 题没有机会上场。说明写代码之前的构思还不够成熟，调试代码没有掌握方法，需要继续加强代码能力。　

***

### 解题报告

#### A. Digits 2

**情况**　通过

**题意**　给定一个 $n$，要求输出一个大整数，满足其是 $n$ 的倍数，并且这个大整数的所有数位之和也是 $n$ 的倍数。

**题解**　将 $n$ 输出 $n$ 遍即可。

<hr />
#### B. Generator 1

**情况**　通过

**题意**　给定一个二阶其次递推以及一个大整数 $n$，求该递推式的第 $n$ 项模 $p$ 的结果。$p \leqslant 2×10^9$。

**题解**　十进制快速幂即可。

<hr />
#### C. Generator 2

**情况**　补题通过

**题意**　给出 $x0$、$a$、$b$、$p$，$x_i = a\cdot x_{i-1}+b \pmod p$，$Q$ 组询问，每次给出一个 $v$，问最小的 $i$ 满足 $x_i \equiv v \pmod p$。

**题解**　将 $x_i$ 的递推式展开之后与 $v$ 列同余等式并移项，就得到 $a^k$ 与常数 $c$ 的同余式，用 BSGS 即可，但复杂度过大，可以增大预处理的复杂度以减小每次询问的复杂度。

<hr />
#### D. Generator 3

**情况**　补题通过

**题意**　给定两个形如 $x_i = ax_{i-1} + b \pmod p$ 的递推式，其中一个作为横坐标，另外一个作为纵坐标，取前 $n$ 个点 $(x_i,\ y_i)$（$0 \leqslant i < n$）。求这 $n$ 个点构成的凸包的面积。$n \leqslant 10^{18}$，$x_0,\ a,\ b,\ p \leqslant 2×10^5$。

**题解**　首先我们注意到 $p \leqslant 2×10^5$，所以不同的横坐标最多为 $2×10^5$ 种。另外，求凸包的时候对于每一个横坐标，实际上只有纵坐标最大和最小的点才有可能在凸包上，所以我们只用尝试对每个横坐标求出纵坐标的极值即可。题中给出的递推式肯定会是一个 $ρ$ 型循环。设横坐标的循环长度为 $l_x$，考虑在 $y$ 中某处跳 $2^k$ 次，每两次间距 $l_x$，所经过的所有纵坐标的极值，这个东西可以用倍增的方法算出。然后对于环上的横坐标，可以依次试位算出对应的纵坐标极值。时间复杂度为 $\mathrm O(p \log n)$。

<hr />
#### E. Independent Set 1

**情况**　补题通过

**题意**　给一个 $26$ 个点的图，求所有导出子图的最大独立集大小之和。

**题解**　枚举子集，$\mathrm{dp}[\mathrm{mask}]$ 表示当前点集的最大独立集，转移考虑一个点，可以不选，或者选了之后在剩下不相连的点中找最大独立集。

<hr />
#### F. Maximum Clique 1

**情况**　通过（-3）

**题意**　给 $n$ 个点，每个点的点权 $a_i$，两个点有边等价于 $a_i \operatorname{or} a_j$ 不是 $2$ 的幂次，求最大团。

**题解**　考虑补图上面求最大独立集，一条边相当于两个权值只有一个二进制位不同，所是一个二分图，可以 Dinic 求出最大独立集。

<hr />
#### G. Subsequence 1

**情况**　通过（-1）

**题意**　给一个母串 $s$，和目标串 $t$，问有多少种方式从 $s$ 中挑出一个子序列使得子序列构成的整数比 $t$ 构成的整数大。

**题解**　首先考虑子序列长度大于 $t$ 的都满足要求，其次考虑 $\mathrm{dp}[i][j][0/1]$ 表示 $s$ 串选第 $i$ 个字符，匹配到了 $t$ 串的第 $j$ 个字符，是不是已经比 $t$ 串大了的方案数，如果不是，则相当于要求在 $s$ 串中匹配 $t$ 串，如果是，那么后边可以随便选数字。最后把两种情况加起来就是答案。

<hr />
#### H. Subsequence 2

**情况**　通过（-2）

**题意**　有一个长度为 $n$ 的字符串 $s$，由前 $m$ 个字母组成，给出只包含 $m$ 个字母其中两个的子序列（一共给出 $m(m-1)/2$ 组），要求还原出 $s$。

**题解**　依次还原 $s$ 的每个位置，开头位置的字母在其任意组合中都一定为开头，确定开头字母后，把它从这些子序列的开头删去，再循环执行上述操作。

<hr />
#### I. Three Points 1

**情况**　补题通过

**题意**　在 $w × h$ 的矩形中找三个点使得两两点之间的距离为 $x$、$y$、$z$。

**题解**　不难发现三个点中必有一个在矩形顶点处，假设从顶点出去的两条边分别为 $x$、$y$，他们能存在的角度范围可以求出，其中一条边在角度边界上一定最优，枚举所有情况即可。$x$、$y$、$z$ 的顺序贼恶心。

<hr />
#### J. Three Points 2

**情况**　补题通过

**题意**　给一棵树，有 $q$ 次询问，每次求三个点，满足两两之间距离分别是 $a_i$，$b_i$，$c_i$。

**题解**　首先考虑一次询问，一定是两个点的一条链，然后在链的某个上支出去一条子链，考虑如果以这个三岔口为根，然后三个子链的长度由 $a$、$b$、$c$ 确定，就要找三颗子树，使得各自的深度比需要的多。那么确定一个根，一定是深度前 $3$ 的子树分别对应由大到小的这三个子链。可以进行换根的 dp 找出每个点为根的前三个子树深度，然后进行三维偏序，找到一组解。可以 cdq 分治，之后再最深的点向根节点走若干步满足题目的要求。