<br /><center class="subtitle">Fudan ICPC Summer Training Camp 2019</center>

# 牛客网第三场训练报告

<br />
<center>[Fudan U2] 刘明君、孙亮亮、薛振梁</center>
<center>2019 年 7 月 25 日</center>
<br />

### 概况

比赛中通过 6 题，赛后补 3 题，总共通过 9 题。

### 比赛过程

这次比赛 xzl 顺序读题，sll 倒序读题，lmj 选题做。xzl 看了 A 后跳过，做 B 题时因为细节问题 WA 了一发，18min 时才通过。之后 29min 时 sll 过了 H 题。之后 lmj 做 A 题，xzl 和 sll 看 D 题。lmj 第一次写 A 题后发现看错题了，后来改了一下后发现分块常数太大，过不了。同时 D 题也想了很久，并且 xzl 在写 D 题时代码有很多细节错误，以及有一些特殊情况没有特判，写了对拍后才在 189min 时通过。之后不久 lmj 就在 196min 时过了 F 题。然后sll 开始写 J 题，由于一开始写的比较随意，交上去总是 WA，后又重写一份，依然不对，但是发现了前一份代码的错误，修改后在 246min 时通过。最后一小时我们选定做 G 题和 I 题。I 题发现性质后 lmj 写了个 DP 在 289min 时通过。G 题实际上也想出了正解，但是被队友抛了个烟雾弹，以为复杂度不对，最后十分钟也没有试着写，而是尝试 A 题卡常，未果。

### 总结

**刘明君：**开场我先看 D、F、G，感觉都是可做的，但是都没有想出来，40min 时 xzl 给我看了 A 题，一下想到是分块，写完发现读错题了，然后改了一下，超时。其他人也都在超时，感觉不太可做，先丢了。但实际上改时限以后并没有很卡常，但是需要比较好的写法。然后 ob 其他两人写 D 和 J，卡了很长时间，中途和 sll 讨论了 F，先没有写，然后在想 A 的其他算法，G 和 I 没想出来，浪费了比较长时间。B、D、F、H、J 都过了以后三个人想 G 和 I，I 想出了结论。一发过掉了。

**孙亮亮：**开场和 lmj 讨论后写了 H，之后在思考 G 题，途中和 xzl 讨论了 D，之后发现 J 题很可做就去上手写 J，但是第一遍写出来 J 有些细节错误耽搁了些时间。G 题虽然想到分治了但是误以为复杂度不对就 pass 了，比赛快结束的时候 xzl 提了分治算法并且说明了复杂度是对的。lmj 想到了枚举最大值从较小区间枚举端点的算法，但是比赛时也误以为复杂度不对。
　　J 题以为是个简单的模拟题就上手写的很丑，导致后来查错也很困难，以后要精细的写代码，G 题分治的思路原本都想到了但是误以为复杂度不对，应该是好久没做分治题目的原因，要加强练习。

**薛振梁：**这一次比赛主要是前期出题不利，我 D 写代码加调代码用了很久，导致最后实际上还有可做的题却没时间写。此外就是 A 题和 D 题都用了偏复杂的方法，也浪费了很多时间。这里面代码的可靠性是可以有提升的，今后需要加强代码能力，尽量避免用对拍调代码的情况。

***

### 解题报告

#### A. Graph Games

**情况**　补题通过

**题意**　给一张图，开始所有边都在，有 $q$ 次操作，每次把一个区间的边的存在性取反，或者查询两个点，问是否对所有点，与 $u$ 直接有边相连等价于与 $v$ 直接有边相连。

**题解**　首先给每个点一个权值，认为如果把和一个点相连的点集变成这个集合的权值异或和。对边的序列分块，单点修改暴力改这个点的相邻点权异或，整块修改打上 `rev` 标记，查询时如果有标记就把这个块对于这个点的权值和异或到这个点上。需要常数优秀。

<hr />
#### B. Crazy Binary String

**情况**　通过（-1）

**题意**　给定一个长度为 $n$ 的 `01` 字符串，问其中最长的子串和子序列的长度，满足子串和子序列中 `0` 和 `1` 的数量相等。$n \leqslant 10^5$。

**题解**　对于子串，将 `0` 视作 $1$，`1` 视作 $-1$，求一遍前缀和，则问题变成问前缀和中相同数字之间的最远距离。对于子序列，答案是 `0` 和 `1` 的出现次数的最小值的两倍。时间复杂度 $Θ(n)$。

<hr />
#### C. Guessing ETT

**情况**　补题通过

**题意**　给定一个 $n$ 个点的树的点欧拉序列（长度为 $m = 2n - 1$），其中有一些元素的值未知，要求补全这个序列使得其成为一个合法的欧拉序列 $a[1..m]$。树的根为 $1$ 号节点。数据保证有解。$n \leqslant 2.5×10^5$。

**题解**　首先注意到 $a[1] = a[m] = 1$。对于每种在序列中出现了的元素 $x$，记 $L[x]$ 和 $R[x]$ 分别表示其在序列中出现的最左边和最右边的位置，因此 $x$ 对应于一个区间 $[L[x],\ R[x]]$。易知最终不同节点对应的区间是不相交的。考虑当前序列中连续的两个元素 $x$、$y$，它们在树上一定是父子关系，因此必定其中一个对应的区间被另外一个元素包围。因此初始时我们扫描所有的连续元素，如果存在没有被包住的情况，则将其补上。如果扫描完后依然有空位，则使用未在序列中出现的元素填补一个位置，然后继续扫描整个序列。上述过程可以使用队列优化。由于只有在填入新元素后才会有新的连续元素的位置，并且这个数量为常数，所以总共考虑的位置个数是线性的。

<hr />
#### D. Big Integer

**情况**　通过（-4）

**题意**　令 $A(n) = (10^n - 1)/9$，现给定 $n$、$m$ 和质数 $p$，求有多少对 $a$、$b$ 满足 $A(a^b) \equiv 0 \pmod p$。$1 \leqslant n,\ m,\ p \leqslant 10^9$。

**题解**　首先特判 $p = 3$ 的情况，之后问题变为求 $10^{a^b} \equiv 1 \pmod p$ 的方案数。然后特判掉 $p = 2$ 和 $p = 5$ 的情况，并求出 $10$ 在模 $p$ 意义下的阶数 $c > 1$，满足 $10^c \equiv 1 \pmod p$。注意 $c \mid (p - 1)$。此时问题就转为求 $a^b \equiv 0 \pmod c$ 的方案数，即 $c \mid a^b$ 的方案数。我们考虑 $c$ 的质因数分解 $c = p_1^{s_1} p_2^{s_2}\cdots p_k^{s_k}$，我们可以将 $a$ 表示成 $pq$ 的形式，其中 $q$ 中仅包含 $c$ 中的质因子，并且次数严格小于 $c$ 中的对应次数，而 $p$ 除了可以包含 $c$ 没有的质因子外，还要满足对于 $c$ 中的质因子，$p$ 中的次数不会更低。这样 $p$ 的部分就不需要用 $b$ 来提高次数，而 $q$ 的部分则决定至少需要多大的 $b$ 来保证 $a^b$ 是 $c$ 的倍数。

因此我们枚举 $c$ 的这种因子 $q$，求出 $b$ 的最小值，然后计算合法的 $p$ 的个数。记 $c'$ 为 $c$ 中仅包含与 $p$ 公共的质因子的部分，注意到 $c' \mid p$，因此这个个数实际上就是：
$$
\begin{aligned}
\sum_{p \geqslant 1} [c' \mid p][pq \leqslant n][p \bot q] &= \sum_{t = 1}^{\lfloor n/pc' \rfloor} [tc' \bot q] \\
&=\sum_{t = 1}^{\lfloor n/pc' \rfloor}\sum_d[d \mid tc'][d \mid q]μ(d) \\
&=\sum_{t = 1}^{\lfloor n/pc' \rfloor}\sum_d[d \mid t][d \mid q]μ(d) & (\text{since } d \mid q \text{ but }c' \bot q) \\
&= \sum_{d\mid q}μ(d)\sum_{t = 1}^{\lfloor n/pc' \rfloor}[d \mid t] \\
&= \sum_{d \mid q}μ(d)\left\lfloor {n \over dqc'} \right\rfloor
\end{aligned}
$$
因此再枚举 $q$ 的因子 $d$ 计算上式即可。时间复杂度 $\mathrm O(???)$。

<hr />
#### F. Planting Trees

**情况**　通过（-1）

**题意**　给一个矩阵，找一个矩形子矩阵，要求内部最大值减最小值小于等于 $m$。求子矩阵最大面积。

**题解**　枚举子矩阵的上下边界，从大到小枚举左边界，那么右边界的最大值随着左边界单调下降，用单调队列维护最大值和最小值，减小右边界直到合法。

<hr />
#### G. Removing Stones

**情况**　补题通过

**题意**　 给定一个长度为 $n$ 的序列，求有多少个区间满足区间之和不小于区间最大值的两倍。$n \leqslant 3×10^5$。

**题解**　考虑枚举区间最大值 $m$，位置为 $k$，易求出其能扩展的区间为 $[l,\ r]$，单调枚举 $[l,\ k]$ 中的左端点，我们可以二分出 $[k,\ r]$ 的临界的右端点，从而算出贡献。对枚举 $[k,\ r]$ 中的右端点同理。因此我们选择较短的一边来枚举，这个过程实际上是启发式合并的逆过程，故时间复杂度为 $\mathrm O(n\log^2 n)$。注意到顺序枚举一边边界时，另外一边的临界边界也是单调的，故可以使用 finger search 来优化二分，达到 $\mathrm O(n \log n)$ 的时间复杂度。

<hr />
#### H. Magic Line

**情况**　通过

**题意**　在二维平面上给出 $n$ 个点，求一条直线将 $n$ 个点平分。$n \leqslant 1000$。

**题解**　按 $x$、$y$ 分别为第一第二关键字排序，找到第 $n/2$ 个点所在的 $y$ 坐标，用一条几近平行于 $x$ 轴的线分开前 $n/2$ 个点和后面的点。

<hr />
#### I. Median

**情况**　通过

**题意**　如果有一个数列 $a$，那么相邻三个数取中位数，可以得到 $b$ 数列。输入 $b$ 数列，求一个合法的 $a$ 数列，或者判断无解。

**题解**　$a$ 数列一定每个数 $ai$ 都是和这个数相关的 $b$ 数列的数 $bi$，$bi-1$，$bi-2$ 之一，否则可以调整到其中之一，那么 dp 记录第 $i$ 个数时，前两个数分别是那两个 $b$ 中的数是否有解。转移时枚举下一个数是 $b$ 中哪个数。

<hr />
#### J. LRU Management

**情况**　通过（-6）

**题意**　维护一个 {`name`, `data`} 序列，有两种操作，第一种是给出一个元素 $x$，在序列中查找和他 `name` 相同的元素，如果不存在把 $x$ 直接插入序列末尾，如果存在则把序列中这个元素移动到序列末尾。第二种操作是找到 `name` 为字符串 $s$ 的元素（下标为 $i$），并输出下标为 $i+v$ 的元素的 `data` ($v \in \{-1,\ 0,\ 1\}$)。

**题解**　用链表 + `map` 模拟即可，直接用 `string` 做 `map` 可能会 T，可以 hash 后 `map`。