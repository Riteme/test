02 Funny String

题意：给定一个字符串 $S$，有多次询问。每次询问在 $S$ 前面或者后面加上一个新的字符 $c$ 得到字符串 $T$，然后询问 $T$ 中第 $i$ 个后缀的排名。

题解：如果是在前面加字符，则只需要和新加入的后缀做个比较即可。

如果是在后面加字符，则除了新加了一个后缀 $c$ 外，之前的每个后缀末尾都加上了 $c$，对排名的变动就比较大。考虑计算原来某个后缀 $T_i$的排名变动，一共有三个来源：

1. 后缀 $c$ 的影响（这个容易忽略）
2. $T_i$ 作为 $T_j$ 的前缀，并且 $c$ 不小于 $T_j$ 对应位置的字符。这些 $T_j$ 在 SA 中一定是 $T_i$ 后面连续的一段，并且对应位置的字符一定是单增的，故可以二分。
3. $T_j$ 是 $T_i$ 的前缀，那么 $T_j$ 实际上是 $T_i$ 的 border。这很容易想到反向 KMP 后建树，然后就是查询点到根的路径上，所有相关字符的排名。这里有个技巧。对于每个 border $T_j$，设其长度为 $L_j$，则我需要比较 $c$ 和 $T[i + L_j]$ 的大小关系。对于最长的 border $T_j$ 还好解决，考虑次长的 border $T_k$，需要比较的字符是 $T[i + L_k]$，当然我们不能全部枚举。由于 $T_j$ 是 border，因此 $T[i + L_k]$ 和 $T[j + L_k]$ 实际上是相同的字符，利用这一点就可以给树上每个点赋一个点权，之后用主席树即可。



03 Boring Game

题意：$n$ 张纸平放，然后反复折叠 $k$ 次，标号，问展开后的排列。

题解：首先对一张纸的情况大力找规律，发现可以递归算出每一次折纸后标号的变化。此外对于多张纸的情况，每一张纸之间是独立的，因此需要做的事情只是提前分配好所有标号即可。