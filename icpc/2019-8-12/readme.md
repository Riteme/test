<br /><center class="subtitle">Fudan ICPC Summer Training Camp 2019</center>

# 杭电第七场训练报告

<br />
<center>[Fudan U2] 刘明君、孙亮亮、薛振梁</center>
<center>2019 年 8 月 12 日</center>
<br />

### 概况

比赛中通过 6 题，赛后补 3 题，总共通过 9 题。

### 比赛过程

<pre class="replay">
|0........|30.......|60.......|90.......|120......|150......|180......|210......|240......|270...... (min)
      x    x  F                                                          xb       H B             xg [lmj]
                         +xx xx      x xA                           x     x   xx     xJ            g [sll]
                  K                             c                                 H   J       c    g [xzl]
*^^^^^^^^^*^^^^^^^^^*^^^^^^^^^*^^^^^^^^^*^^^^^^^^^*^^^^^^^^^*^^^^^^^^^*^^^^^^^^^*^^^^^^^^^*^^^^^^^^^
 x   Wrong Answer / Presentation Error              !   Runtime Error
 +   Time Limit Exceeded                            =   Memory Limit Exceeded
A-N  Accepted                                      a-n  可做但未通过 / 弃题 / 屯题
</pre>

### 总结

**刘明君：**比赛中代码错误太多了，F 题 WA 了两发，B 题调了很久，如果能一次过掉的话能给 G 和 C 节省出很多时间。

**孙亮亮：**本场负责的两道题都有太多情况没考虑清楚，下次要 think twice，code once。

**薛振梁：**这场主要是调题花的时间太久，导致其余能做的题没有机会或者是不能及时补正。以后写代码需要思考清楚。

***

### 解题报告

#### A. A + B = C

**情况**　通过

**题意**　给出 $a$，$b$，$c$，求一组可行的 $x$，$y$，$z$，满足 $a\cdot10^x+b\cdot10^y=c\cdot10^z$。

**题解**　首先考虑 $a$，$b$，$c$ 不含后缀 $0$ 的情况，此时 $x$，$y$，$z$ 必然存在至多只有一个不为 $0$ 的情况，枚举哪个不为 $0$，用其他两个为 $0$ 的情况求出不为 $0$ 这一项的值，判断是否可行即可。

<hr />
#### B. Bracket Sequences on Tree

**情况**　通过

**题意**　给一颗无根树，问在不同的点当成根，选择不同的选择儿子 DFS 的顺序，有多少种入栈出栈的 DFS 括号序列。

**题解**　注意到括号序列相同等价于两个树同构，那么以 $1$ 号点为根进行 DP，算出每个点的子树的括号序列个数，转移是所有子树的方案数乘积再乘上把同构的子树看成同类物品的多重组合数。之后进行换根 DP 算出其他点当成根的方案数。

<hr />
#### C. Cuber Occurrence

**情况**　补题通过

**题意**　对于字符串的匹配，将重叠或者恰好相邻的匹配算作一处，计算总的匹配数（例如 `ana` 在 `banana` 中的匹配数为 $1$）。现给出母串 $s$，要求求出一个字典序最小的匹配串，满足匹配数恰好为 $K$，或者报告无解。$|s| \leqslant 10^5$。

**题解**　首先匹配串一定是母串的某个子串。考虑如何计算一个串的匹配数：首先求出所有的匹配位置，然后计算有多少对相邻的匹配位置之差不超过匹配串的长度，则匹配数为匹配位置总数减去之前统计出的对数。反映到后缀树上就是某个子树内计算所有叶子的差分序列中有多少个元素不超过当前串的长度。所以使用启发式合并 `set` 加平衡树维护差分序列，在后缀树的边上进行二分来检查边上是否有某个位置的匹配数为 $K$，然后再在后缀树上 DFS 找到字典序最小的解即可。时间复杂度为 $\mathrm O(|s| \log^2 |s|)$。

<hr />
#### D. Data Structure Problem

**情况**　补题通过

**题意**　维护一个数据结构，支持平面上加点，删点，求一对点使得两个点的点积最小，数据随机。

**题解**　答案一定出现在凸包上的两个点，因为数据随机，凸包的大小是 $\log n$ 的，对于加点操作，暴力把原凸包和这个点求凸包 ，删点操作，如果在凸包上的话，就暴力重构，概率是 $\log n\over n$，期望重构 $q\log n\over n$ 次，一次需要 $\mathrm O(n\log n)$ 的复杂度。

<hr />
#### F. Final Exam

**情况**　通过

**题意**　有 $n$ 个科目可以复习，如果在一个科目上花费 $x$ 的时间，并且考试中这个科目的难度小于 $x$，就可以在考试中回答出这个科目的问题。考试的所有难度之和是 $m$，问在被出题人针对地分配考试难度的情况下，如果想通过 $k$ 个科目，需要复习多少时间。

**题解**　出题人会选你复习的最少的科目达到你复习的时间 $x$，所以要求最少的 $n-k+1$ 门科目的复习时间和大于 $m$，所以答案是 $a+1,\ a+1,\ ...,\ a+1,\ a,\ a,\ ...,\ a$ 的形状。

<hr />
#### G. Getting Your Money Back

**情况**　补题通过

**题意**　现在有 $[x,\ y]$ 个东西存在银行里面，现在可以和银行取出 $c$ 个东西，如果取出成功了，会花费 $a$ 块钱，如果东西不够 $c$ 个，就会取不出来，并且花费 $b$ 块钱。你可以交互地和银行取东西，并且及时得到反馈。问按照最优策略，最坏情况下如果想确保所有东西取出来，需要多少钱。

**题解**　枚举取出 $c$ 个东西，DP 转移方程是 $\mathrm{dp}[x,\ y]=\min\limits_{c=x}^y \{\max\{\mathrm{dp}[0,\ y-c]+a,\ \mathrm{dp}[x,\ c-1]+b\}\}$，可以转移是两个单调函数取最大值，可以通过二分找到最低点，快速进行转移。

<hr />
#### H. Halt Hater

**情况**　通过

**题意**　在一个无穷大网格上，每个格点处需要等待 $a$ 的时间左转，等待 $b$ 的时间执行，但是可以无需等待就右转。有 $t$ 次询问，每次给一个终止格点 $(x,\ y)$，问从 $(0,\ 0)$ 处出发到终点的最少的等待时间是多少。$t \leqslant 10^5$，$-10^9 \leqslant x,\ y \leqslant 10^9$。

**题解**　由于右转无需等待，因此可以将只右转可到达的四个点看做一个街区，那么不难发现，直行就是进入上下左右四个街区之一，而左转就是进入左上、左下、右上、右下四个街区之一。枚举终点所在的街区，现在问题变为从 $(0,\ 0)$ 开始，每次可以斜着走一格，花费 $a$ 的代价，也可以横着、竖着走一格，花费 $b$ 的代价，问走到 $(x,\ y)$ 的最少代价为多少。这个问题对 $a$、$b$ 之间的大小关系简单讨论即可。

<hr />
#### J. Just Repeat

**情况**　通过

**题意**　两个人进行博弈，先手有 $n$ 张牌，后手有 $m$ 张牌，两人轮流出牌，甲出过一张数值为 $i$ 的牌之后乙不能再出该数值的牌，两人足够聪明，不能出牌者输，求问谁胜。

**题解**　对于共同拥有的牌 $i$，显然应该尽量出 $\mathrm{cnt}_1[i] + \mathrm{cnt}_2[i]$ 最大的，排序后贪心即可。$10^7$ 居然直接快排也能过，我和我的小伙伴都惊呆了。

<hr />
#### K. Kejin Player

**情况**　通过

**题意**　一个游戏里面有 $1$ 到 $n + 1$ 种等级，已知从第 $i$ 级升到第 $i + 1$ 级需要花费 $a_i$ 的代价，并且只有 $p_i$ 的成功率，如果不成功则会掉到 $1 \leqslant x_i \leqslant i$ 级。现给出 $q$ 次询问，每次询问从第 $l$ 级升到第 $r$ 级的期望代价是多少。答案对 $998244353$ 取模。$n,\ q \leqslant 5×10^5$，$1 \leqslant l < r \leqslant n$。

**题解**　利用期望的线性性即可。设 $E_i$ 为第 $i$ 级升到第 $i + 1$ 的期望代价，则容易列出：
$$
E_i = a_i + (1 - p_i) \sum_{j = x_i}^i E_i
$$
将等式右边的 $E_i$ 移项后就得到了 $E_i$ 的递推式。每次询问的答案就是 $\sum_{i = l}^{r - 1} E_i$。