<br>
<br>
<br>
<br>
<br>

# 动态最短路

<br>
<br>

<center>薛振梁　18307130172</center>
<center>2019 年 12 月 23 日</center>
<br>
<br>

### 概述
使用 “地标”（landmarks）作为估价函数的双向 A\* 算法。在点数 $n$ 和边数 $m$ 约为 $10^6$ 级别的随机图时单次询问时间 $< 10\mathrm{ms}$；对于 $n$ 只有 $10^3$ 级别的稠密随机图，如果没有删边操作，单次询问时间 $< 0.05\mathrm{ms}$，每次询问平均访问边数上界约为 $500$，最优秀的时候只有 $50$ 左右。

由于要想从最坏时间复杂度的角度来优化动态最短路感觉非常困难，因此这里我主要考虑单次询问的平均用时。计时部分使用的是 C++ 标准库里的 `high_resolution_clock`，对 $q$ 次询问记录一个总时间，然后计算平均用时。此外，算法在处理询问之前需要做一些预处理，这一部分个人认为只要时间不是过长就可以接受。预处理部分的时间基本上控制在 $20\mathrm{s}$ 内。

测试数据只尝试了完全随机加边、随机询问的生成器。算法在当图比较稠密或比较稀疏时有不同的参数。

***

### 编译环境
由于使用了一些语法糖，编译代码需要开启 C++ 17 特性。

### 代码和算法架构
#### `Graph` & `SPTree`
`Graph` 表示一张图，使用邻接表存储。`SPTree` 表示一个有源点的最短路树。

<br />

#### `SPFAAlgorithm` & `DijkstraAlgorithm`
分别为单源最短路的 SPFA 算法和 Dijkstra 算法，主要用于预处理原图。SPFA 算法的实现使用了所谓 SLF 的优化，即新点入队列时，如果最短路距离比队首小，则直接进入队首。实测在随机图上性能略优于 Dijkstra 算法。

<br />

#### `Solver`
这一部分是主算法。构造函数是预处理的代码。预处理部分随机抽取了 `TMAX` 个源点计算最短路树，用于之后计算估价函数。每一次计算完最短路树后，都会根据当前的最短路树对原图进行剪边：对于非树边，如果边的长度不小于边的端点在树上的距离，则这条边对于最短路的计算是没有意义的。快速实现这个剪边算法需要计算出所有边在最短路树上的距离，这里使用的是 Tarjan 的 LCA 算法（`TarjanLCA` 类），可以在 $\mathrm O((n + m) α(n))$ 的时间完成处理。这个优化对于稠密图十分明显。但有一个问题是如果需要支持删边，则不能使用剪边后的图。一个可能可行的解决办法是对于不优的边采取一定概率进行丢弃，保留多份简化后的图，以应对删边很少时的情况。由于时间原因，这个想法暂时没有实现。

`query` 函数是查询，使用的是双向 A\* 算法 [^2]。A\* 算法的实际实现部分在 `search` 函数中，其流程与 [2] 中的描述基本一致。我之前尝试过自己设计双向 A\* 算法，但结果并不成功，在两个方向的搜索交界的地方的处理不是很好。[2] 中提出的双向 A\* 算法在流程上更为简洁，其关键部分在于第 470 行处的状态剪枝：

```c++
// In Solver::search
if (dist[i][u] + h(u, ed[i]) >= ans ||
    dist[i][u] + mi[i ^ 1] - h(u, ed[i ^ 1]) >= ans)
    continue;
```

使得该算法相比一般的 A\* 算法访问的边数减少了至少一倍以上。

估价函数 $h(u,\ v)$ 的主要目标是给出图中 $u$、$v$ 两点间的最短距离的下界。考虑任取一棵最短路树，设最短路树的根节点 $s$ 到某点 $u$ 的最短距离为 $δ(s,\ u)$，图中两点 $u$ 和 $v$ 的实际最短距离为 $δ'(u,\ v)$，则根据三角不等式：

$$
δ(s,\ u) + δ'(u,\ v) \geqslant δ(s,\ v)
$$

再根据无向图上最短路长度的对称性，易知：

$$
δ'(u,\ v) \geqslant |δ(s,\ u) - δ(s,\ v)|
$$

受此启发，我们在原图中选取一些源点 $S = {s_1,\ s_2,\ ...,\ s_k}$ 来计算单元最短路，于是估价函数定义为：

$$
h(u,\ v) = \max\limits_{s \in S}\{|δ(s,\ u) - δ(s,\ v)|\}
$$

当选取的源点越多时，估价函数给出的下界也会更优，从而能够帮助 A\* 剪去更多不必要的分支。但有一个问题是，现在这个估价函数的计算需要遍历 $|S|$ 次来取最大值，如果选取的源点过多反而会降低最短路的效率。之后我受到 [1] 中的启发，实际上我们只需要选取比较好的几个源点来进行估价的就可以了。于是在正式搜索前，我按照给出的从起点到终点的距离的估计值作为关键字，使用 `nth_element` 选取了前几个（由参数 `CMAX` 控制）比较优秀的源点用于估价。

<br />

#### `BCTree`
主要是用于处理原图不连通的情况。实际上还处理了图中的割点，即最短路算法只用在每个点双连通分块上跑就可以了。但实际效果并不明显，因为随机图以及正常的交通平面图总是倾向于没有割点。这一部分的主要作用是快速判断起点和终点是否在同一连通块内，避免最短路算法遍历整张图。

### 参考文献

[^1]: "Efficient Point-to-Point Shortest Path Algorithms". from Princeton University.
[^2]: Pijls, Wim; Post, Henk "Yet another bidirectional algorithm for shortest paths" In *Econometric Institute Report EI 2009-10/Econometric Institute, Erasmus University Rotterdam. Erasmus School of Economics*.