# 水题选讲: Day10 T2 Star
## 原题题意
在平面直角坐标系$ xOy $中，给你$ n $条直线。
每条直线$ l_i $以$ A_ix + B_iy + C_i = 0 $的形式给出。
求出所有的直线的交点中，同时交于一点的直线的数量的最大值为多少，有多少个这样的交点？

### 输入
第一行: $ n $
接下来的$ n $行: $ A_i $, $ B_i $, $ C_i $

### 样例输入
```
3
0 1 0
1 0 0
1 1 -1
```

### 样例输出
```
2 3
```

### 数据范围
$ n \le 1000 $

## 做法
这是一道简单的数学题，先把两条直线求交点的公式直接列出来:
> 已知 $ l_1: A_1x + B_1y + C_1$ 和 $ l_2: A_2x + B_2y + C_2 $，
> $ l_1 $ 与 $ l_2 $ 的交点 $ l_1 \cap l_2 = P $ 的横坐标$ x $为:
> $$ x = {C_2B_1 - C_1B_2 \over A_1B_2 - A_2B_1}\tag{1.1} $$
> 然后将$ x $代入直线便可求出$ y $。

于是乎直接枚举两两直线的交点即可，这个过程复杂度为$ \Theta (n ^ 2) $。

然而这道题思想很简单，关键在于许多细节。
#### 1. 类型选择与精度问题
交点可能为小数，因此要选用浮点型。  
另外不能用`float`，要用`double`，我就是最后五分钟改成`float`然后掉了60分。
因为当初考虑到用`double`会超时...其实并不然...

判定浮点数相等不能直接用`==`，毕竟浮点数精度不高，但可以设定一个可容忍的精度范围：
```python
def almost_equal(a, b):
	return abs(a - b) < 0.0001
```
上面的`almost_equal`函数的容忍精度为$ 0.0001 $。
即只要$ a $和$ b $之间差距不超过$ 0.0001 $，就认为这两个数是相等的。

#### 2. 数学计算的特殊情况
上面的公式中，当$ A_1A_2 = 0 $或$ B_1B_2 = 0 $时是不行的，这两中特殊情况要分类处理。
当两条直线平行时没有交点，特判一下就好。

#### 3. 哈希表存储结果
如果不用哈希表以$ \Omega (1) $的时间复杂度来存储计算结果的话，将导致总复杂度的暴增。  
因此要手写个哈希表。

给个哈希表中数据的一种存法：
```python
struct Node:
	# x, y用于确定交点的身份
	double x
    double y
    set lines  # 表示交于此处的直线的集合，存储直线的id即可
```
如果不用`set`存储直线的话，会导致答案错误。
因为假设$ l_1 \cap l_2 = P $，且$ l_1 \cap l_3 = P $，如果是每次求得交点时将答案加`2`，很显然$ l_1 $被计入了两次。
C++中`set`是用红黑树实现的，只会导致总复杂度变为$ \Theta (n ^ 2 \log n) $，可以AC。
最后，`lines`中元素的个数即为答案。

给个哈希函数：
```python
def h(x, y):
	return (((int)x) << 1) + (((int)y) >> 1)
```

#### 4. 计算第二个答案
理论上第二个答案在计算中用个新的哈比表存会快一些，但是我在考试时发现还不如遍历一遍原来的哈希表快...  
因此我是直接遍历统计了一遍...