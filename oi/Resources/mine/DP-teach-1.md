# 某OJ某题：饥饿的牛
## 题目
### 描述
牛在饲料槽前排好了队，饲料槽依次用1到N**(1<=N<=2000)**编号。  
每天晚上，一头幸运的牛根据约翰的规则，吃其中一些槽里的饲料。  
约翰提供B个区间的清单。一个区间是一对整数start-end，1<=start<=end<=N，表示一些连续的饲料槽。  
比如1-3,7-8,3-4等等。牛可以任意选择区间，但是牛选择的区间不能有重叠。  
当然，牛希望自己能够吃得越多越好。给出一些区间，帮助这只牛找一些区间，使它能吃到最多的东西。  
在上面的例子中，1-3和3-4是**重叠**的；聪明的牛选择{1-3，7-8}，这样可以吃到5个槽里的东西。

### 输入
第一行，整数B**(1<=B<=1000)**
第2到B+1行，每行两个整数，表示一个区间，较小的端点在前面

### 输出
仅一个整数，表示最多能吃到多少个槽里的食物。

### 样例输入
```
3
1 3
7 8
3 4
```

### 样例输出
```
3
```

## 题目本质
题目中说了一大堆，实际上是在讲一个这样的问题：  

> 已知```B```个区间，每个区间是一个闭区间```[i, j]```，其中```1 <= i <= j <= N```  
> 现在求一个最大的区间集合，使得集合内任意两个区间的交集为空集  
> 输出区间长度总和

## 分析
### 暴力？
当然不可能啦，因为我们需要考虑```1000!```种情况。  
这个数是多大呢，请看下面这张图：
![](http://git.oschina.net/riteme/test/raw/master/pic/dp-teach-1.png?dir=0&filepath=pic/dp-teach-1.png&oid=314adbfd045a49a94fe649d7ede4d49d33007e27&sha=edc93d917405c026e69659a1779ad01477fb9bd4)
所以不要考虑了...

### 贪心？
之前有一道活动安排的题目，和这道题很相似。  
在活动安排中，按照结束时间的升序来考虑便可得到最多能安排的活动数。  
但在此处是要求求出最大区间长度总和，在用贪心时处理**重合的区间**时会非常麻烦。  
因此不考虑贪心。

### 动态规划！
#### 初步分析
和贪心相似，在考虑动态规划时也是考虑区间结尾的。  
在考虑之前，对于选不选取一个区间，有如下的性质：

> 若区间```A```为```[i, j]```，当```N < j```时，这个区间无法选入

因此，只有当```N == j```时，我们才考虑是否选取该区间。  
此外，**可能有多个区间**的结尾是一样的。对于这种情况，只要选出一个最大的即可。

#### 状态转移
先放图：
![](http://git.oschina.net/riteme/test/raw/master/pic/dp-teach-2.png?dir=0&filepath=pic/dp-teach-2.png&oid=3476312859c9fd69c3942133f455b913eb117226&sha=f5eb37e944b236bd29155ba37628a5367f447ee4)
其中：```f[j]```表示在```[1, j]```内区间总长度能达到的最大值。  
显而易见，对于某一个区间只有选或不选两种状态。

##### 1. 选择它
我们先考虑选择某一区间时，如何求得最大值：  
1. 首先时自身的长度```length = j - i + 1```  
2. 因为不能有区间与它重合，所以从```f[i]```到```f[j-1]```的所有的值都是不可用的。  
所以，我们还需知道```f[i-1]```的值，即在这个区间之前能达到的最大值。   
最后得到的就是图上说的那个方程式。  

##### 2. 不选它
这个情况很简单，只要使```N < j```就不会选到它。  
有因为要使值最大，所以应当取```f[j-1]```。

最后，我们得到状态转移方程即为：
```
f[j] = max[f[j - 1], f[i - 1] + length}
```

## 代码实现
有了状态转移方程，代码就很好写了。  
只是需要注意之前在**初步分析**时的讨论到的结尾重合的情况，然后这道题就AC啦。

类伪代码：
```python
f = []
for i in range(0, N + 1):
    f.append(0)

for i in range(1, N + 1):
    for interval in intervals:
        s = begin_of(interval)
        e = end_of(interval)
        length = length_of(interval)

        if e == i:
            f[e] = max(f[e], f[s - 1] + length)

    f[i] = max(f[i - 1], f[i])

print(f[N])
```
