<center><font style="font-size: 20px">NOIP 模拟赛 Day 2</font></center>
<center>by riteme</center>
<br/>
### <center>微小的数学</center>
#### Tags
ruanxingzhi / 数学 / 组合恒等式、快速幂。

#### 题解
经典的组合恒等式：

$$ k\binom{n}{k} = n\binom{n - 1}{k - 1} $$

可以通过展开组合数公式来直接证明，也可以通过组合方法来证明，具体方法可以参考这里：`http://riteme.github.io/blog/2017-6-19/double-count.html#_4`

由此我们可以推出：

$$ \sum_{k = 0}^n k \binom{n}k = n\sum_{k = 1}^{n} \binom{n-1}{k-1} = n\sum_{k = 0}^{n-1} \binom{n-1}{k} = n2^{n-1} $$

考虑到等差数列 $a_k = s + kd$，所以：

$$ \begin{aligned} \sum_{k = 0}^n a_k\binom{n}k & = \sum_{k = 0}^n (s + kd)\binom{n}k \\ & = s\sum_{k = 0}^n\binom{n}k + d\sum_{k = 0}^n k\binom{n}k \\ &= s\sum_{k = 0}^n\binom{n}k + nd\sum_{k = 1}^{n} \binom{n - 1}{k - 1} \\ &= 2^ns + 2^{n - 1}nd = (2s + nd)2^{n - 1} \end{aligned} $$

使用快速幂计算 $2$ 的幂次，时间复杂度为 $\Theta(\log n)$。

*****

### <center>椰贼斗恶⻰</center>
#### Tags
Link / DP / `bitset`。

#### 题解
题意可以理解为：记录 $a_i$ 为最长不下降子序列的长度为 $i$ 的长度为 $n$ 的 `0`/`1` 序列的数量。其中这些 `0`/`1` 序列的某些位置已经被钦定。你需要回答 $a_1..a_n$ 中哪些是奇数。

考虑使用 DP 来解决这个问题，设 $f(i, \;j, \;k)$ 表示已经考虑了前 $i$ 位，并且当前以 $0$ 结尾的最长不下降子序列长度为 $j$，以 $1$ 结尾的最长不下降子序列长度为 $k$ 的方案数。考虑枚举第 $i + 1$ 位上的情况：如果第 $i + 1$ 位上是 $0$，那么 $f(i,\;j,\;k)$ 可以转移到 $f(i + 1,\;j + 1,\;k)$；如果 $i + 1$ 位上是 $1$，那么 $f(i,\;j,\;k)$ 可以转移到 $f(i + 1,\;j,\;\max\{j, \;k\} + 1)$。对于每个 $f(n, \;j,\;k)$，它代表的就是最长不下降子序列长度为 $\max\{j,\;k\}$ 的 `0`/`1` 序列的数量，可以以此来统计 $a_i$。由于最后只用回答奇偶性，所以所有加法均可使用异或来代替。

很不幸，以上 DP 的复杂度为 $\Theta(n^3)$。如果没有小常数实现无法通过此题。

观察 DP 转移的过程：如果以 $j$ 为行，$k$ 为列，那么第一个转移相当于将前一行每个格子加到后一行对应的格子上面去。而第二个转移由于是取最大值的原因，我们就按照对角线进行分类讨论，如果某个格子在对角线上方，那么就将它加到它右边的格子上。如果是正好在对角线上或者在其下方，则加给对角线那一行右边的第一个格子上。由于我们已经使用异或来代替加法运算了，所以我们可以使用 `bitset` 来优化转移过程，时间复杂度为 $\Theta(n^3 / w)$。$w$ 为机器位长，通常为 $32$，可以通过所有测试点。

*****

### <center>将夜</center>
#### Tags
Haogram / 图论 / 网络流、点双连通分量、最近公共祖先、圆方树。

#### 算法 1
对于 $q \leqslant 10$ 的数据：

考虑建立网络流模型来解决这个问题。首先将原图的中的所有无向边都拆成两条有向边。对于原图的每个点都在流网络中建两个点，一个用于与入边相连，一个用于与出边相连，然后这两个点之间连一条有向边，这样可以保证经过这个点的时候必定经过它们之间的边。由于每个点只能经过一次，所以我们可以在那条边上限制流量上界为 $1$。考虑到需要经过 $v$ 这个中介点，可以转换为从 $v$ 开始找出两条分别到 $s$ 和 $t$ 的路径。所以我们将源点与 $v$ 连接一条流量上界为 $2$ 的边，表示有两条道路，然后将 $s$ 和 $t$ 分别向汇点连接一条流量上界为 $1$ 的边。如果这张图的最大流为 $2$ 则说明有解。否则说明无解。

由于最大流至多为 $2$，所以增广路算法最多运行 $2$ 次，时间复杂度为 $O((n + m)q)$。

#### 算法 2
考虑在一张点双连通的图（即删去任意一个点都不会使得图不连通）上，对于任意的 $s \neq t$，可以发现总是存在这样的路径。

现在来证明这是正确的：由于图是连通的，所以 $s$ 到 $t$ 的路径是一定存在的。因此现在只用考虑与 $v$ 相关的路径。假设不存在这样的路径，那么从 $s$ 到 $v$ 的每条路径与从 $t$ 到 $v$ 的每条路径都相交，那么这些路径的交路径必定不为空。而删去交路径上的点将会导致 $v$ 与 $s$ 和 $t$ 不连通，因而违反了点双连通的性质，从而证明了上述结论。

考虑将这个结论推广到任意图上。对于任意两个点双连通分量，最多只会有一个公共点。如果 $s$ 和 $v$ 不在同一个点双连通分量内，那么将 $s$ 改为 $s$ 到 $v$ 的任意路径上最后一个割点，对 $t$ 也做同样的操作。之后如果 $s = t$，则说明这样的路径是不存在的。因为每个点只能经过一次，而 $s = t$ 则表明同一个割点被要求经过两次，故方案不存在。另一方面，如果 $s \neq t$，这样的方案则是一定存在的，正确性已经被之前的结论说明了。

因此我们可以将图缩点双连通分量，比较方便的办法就是构建圆方树这种东西。下面借用一张图：

<img width=550px src="http://images2015.cnblogs.com/blog/818023/201607/818023-20160722194726841-1553255255.png">

具体的圆方树可以比上面更简单。具体而言，就是一张图，保留所有的割边，然后对于每个点双连通分量，删去其中所有的边，并且建立一个新点，称之为方点。对应的，原图中的点则称之为圆点。方点向所有点双连通分量内的点连边。所以真实情况是长这样子：

<img width=650px src="https://git.oschina.net/riteme/blogimg/raw/master/other/yfs.png">

这样做有什么好处？我们发现这是一棵树，$s$ 和 $t$ 在树上的路径是唯一的，而且如果 $s$ 和 $t$ 经过之前转换割点的方法变化之后，如果 $s \neq t$，那么这条树上的路径是一定会经过一个与 $v$ 相邻的方点。反之则不经过方点。这样一来判定的方法就大大简化了：我们只需要检查 $s$ 到 $t$ 在圆方树上的路径是否经过了一个与 $v$ 相邻的方点，或者 $v$ 本身就在这条路径上。

现在还剩一个问题，就是与 $v$ 相邻的方点数量可能很多（考虑一张菊花仙人掌）。此时我们不能暴力枚举 $v$ 附近的方点，而是要通过分类讨论来判定。我们一共分为三种情况：

1. $s$ 和 $t$ 都在 $v$ 的子树内：要么 $v$ 在 $s$ 到 $t$ 的路径上，要么 $s$ 和 $t$ 的最近公共祖先是方点，并且这个方点的父亲是 $v$。
2. $s$ 和 $t$ 只有一个在 $v$ 的子树内：此时 $v$ 一定在 $s$ 到 $t$ 的路径上。
3. $s$ 和 $t$ 都不在 $v$ 的子树内：那么 $v$ 的父亲必须是方点，且在 $s$ 到 $t$ 的路径上。

这样，我们可以使用 Tarjan 算法来计算点双连通分量，使用 Tarjan 最近公共祖先算法来计算每对 $s$ 和 $t$ 的最近公共祖先。时间复杂度为 $O(m + (n + q) \alpha(n))$。
