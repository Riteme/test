#### A. GPA

**题意**　给定长度为 $n$ 的数组 $s[1..n]$ 和 $c[1..n]$，最多可以删除 $K$ 个元素，使得：
$$
{\sum_k s[k]c[k] \over \sum_k s[k]}
$$
尽可能大。输出最大值。$n \leqslant 10^5$。

**题解**　二分答案 $w$。如果答案大于 $w$，那么满足：
$$
\begin{aligned}
&\sum_k s[k]c[k] > w\sum_k s[k] \\
\Leftrightarrow &\sum_k s[k]\cdot(c[k] - w) > 0
\end{aligned}
$$
所以二分的时候将 $c[k]$ 全部减去 $w$，然后挑选 $s[k]c[k]$ 中最大的 $n - K$ 项，检查它们的和是否大于 $0$，并据此调整答案范围。时间复杂度 $O(n \log n \log W)$，$W$ 表示值域。

#### D. INV

**题意**　将 $2,\,4,\,...\,2n$ 的一个排列按顺序插入到序列 $1,\,3,\,...,\,2n - 1$ 中，求插入后的序列的逆序对数的最小值。$n \leqslant 2 \times 10^5$。

**题解**　将相邻两个奇数间的位置按顺序标号，那么待在同一个位置的所有偶数一定是连续的一段。

此外还注意到，对于任意连续的一段，它们最后所待在的位置由它们中的中位数决定。

因此一段偶数的中位数指示了这一段偶数要去的地方。进一步发现，如果两段不同的偶数的旅行路径交叉了，那么它们会在途中合并。

因此使用数据结构来模拟合并的过程，并且要支持动态求出中位数。模拟的时候使用一个栈，按照偶数排列的顺序从右边依次进入序列，前往它要去的地方。如果中途遇到一段偶数（也就是栈顶的一段），就合并，并继续行进（目的地可能改变）。当所有数字加入完毕后，栈中就是插入的方案。

使用线段树可以支持均摊 $O(\log n)$ 的合并，同时可以动态查询第 $k$ 大的值。最后总时间复杂度为 $O(n \log n)$。

#### F. TAKE

**题意**　给定一个长度为 $n$ 的序列，第 $i$ 个位置上有 $p_i$ 的概率出现 $d_i$，$1 - p_i$ 的概率出现 $0$。问这个序列以 $0$ 开头的单调子序列的期望长度是多少。$n \leqslant 10^5$。

**题解**　单独考虑每个位置对答案的贡献：如果位置 $i$ 要出现在单调子序列里面，那么在它前面的所有大于等于 $d_i$ 的数字都不能出现，此外自己需要出现。这样的概率为 $p_i$，再乘上前面大于等于 $d_i$ 的数字的 $1 - p_k$ 的乘积。使用树状数组处理这个二维偏序问题即可。时间复杂度 $O(n \log n)$。